# -*- coding: utf-8 -*-
"""Subset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d1Gz9C1drVPOvE3l9Fnq-Ljak21_4M4f
"""

import os
import glob
import pandas as pd
import shutil
from sklearn.model_selection import train_test_split
from tqdm import tqdm
import numpy as np

# --- CONFIGURACIÓN ---
SOURCE_ROOT = '/content/drive/MyDrive/Challenge_China/train'       # Tu carpeta original gigante
TARGET_ROOT = '/content/drive/MyDrive/Challenge_China/train_mini'  # La nueva carpeta pequeña
SAMPLE_RATIO = 0.15  # 5% de los datos (aprox 2,000 imágenes)
SEED = 42            # Semilla para reproducibilidad

def create_subset():
    print(f"--- Iniciando creación de Subset ({SAMPLE_RATIO*100}%) ---")
    print(f"Origen: {SOURCE_ROOT}")
    print(f"Destino: {TARGET_ROOT}")

    # 1. Preparar directorios
    source_csv_dir = os.path.join(SOURCE_ROOT, 'csv_files')
    target_csv_dir = os.path.join(TARGET_ROOT, 'csv_files')

    if os.path.exists(TARGET_ROOT):
        print(f"¡Atención! La carpeta destino {TARGET_ROOT} ya existe.")
        val = input("¿Deseas borrarla y crearla de nuevo? (s/n): ")
        if val.lower() == 's':
            shutil.rmtree(TARGET_ROOT)
        else:
            print("Operación cancelada.")
            return

    os.makedirs(target_csv_dir)

    # 2. Cargar todos los datos originales
    print("\nCargando índice de datos...")
    csv_files = glob.glob(os.path.join(source_csv_dir, '*.csv'))
    full_df = pd.DataFrame()

    # Diccionario para rastrear a qué archivo CSV pertenece cada fila
    # Esto es vital para recrear los múltiples CSVs al final
    df_map = {}

    for f in csv_files:
        filename = os.path.basename(f)
        df = pd.read_csv(f)
        df['original_csv_filename'] = filename
        full_df = pd.concat([full_df, df], ignore_index=True)

    print(f"Total original: {len(full_df)} muestras.")

    # 3. Muestreo Estratificado
    # Usamos 'task_id' para asegurar que ninguna tarea pequeña desaparezca
    print("Realizando muestreo estratificado...")
    try:
        # train_test_split es genial para estratificar
        _, subset_df = train_test_split(
            full_df,
            test_size=SAMPLE_RATIO,
            stratify=full_df['task_id'],
            random_state=SEED
        )
    except ValueError as e:
        print("Advertencia: Alguna clase tiene muy pocos miembros para estratificar.")
        print("Usando muestreo aleatorio simple para esas clases...")
        subset_df = full_df.groupby('task_id', group_keys=False).apply(
            lambda x: x.sample(frac=SAMPLE_RATIO, random_state=SEED) if len(x) > 20 else x.sample(n=min(len(x), 1), random_state=SEED)
        )

    print(f"Tamaño del Subset: {len(subset_df)} muestras.")

    # 4. Copiar Archivos (Imágenes y Máscaras)
    print("\nCopiando archivos físicos...")
    copy_count = 0
    error_count = 0

    # Iterar sobre el subset
    for _, row in tqdm(subset_df.iterrows(), total=len(subset_df)):
        try:
            # --- Lógica de Rutas ---
            # Las rutas en el CSV son relativas a la carpeta 'csv_files'
            # Ejemplo: ../part1-image/img01.jpg

            # 4.1 Copiar Imagen
            img_rel_path = row['image_path']
            src_img_path = os.path.normpath(os.path.join(source_csv_dir, img_rel_path))
            dst_img_path = os.path.normpath(os.path.join(target_csv_dir, img_rel_path))

            # Crear subcarpetas destino si no existen
            os.makedirs(os.path.dirname(dst_img_path), exist_ok=True)
            shutil.copy2(src_img_path, dst_img_path)

            # 4.2 Copiar Máscara (si existe y es segmentación)
            if row['task_name'] == 'segmentation' and pd.notna(row.get('mask_path')):
                mask_rel_path = row['mask_path']
                src_mask_path = os.path.normpath(os.path.join(source_csv_dir, mask_rel_path))
                dst_mask_path = os.path.normpath(os.path.join(target_csv_dir, mask_rel_path))

                os.makedirs(os.path.dirname(dst_mask_path), exist_ok=True)
                if os.path.exists(src_mask_path):
                    shutil.copy2(src_mask_path, dst_mask_path)
                else:
                    print(f"Warning: Máscara no encontrada {src_mask_path}")

            copy_count += 1

        except Exception as e:
            error_count += 1
            # print(f"Error copiando {row['image_path']}: {e}")

    # 5. Generar nuevos CSVs
    print("\nGenerando nuevos archivos CSV...")
    # Agrupamos por el nombre del archivo original para recrear la estructura exacta
    for csv_file, group_df in subset_df.groupby('original_csv_filename'):
        # Quitamos la columna auxiliar que añadimos
        save_df = group_df.drop(columns=['original_csv_filename'])
        save_path = os.path.join(target_csv_dir, csv_file)
        save_df.to_csv(save_path, index=False)

    print(f"\n--- Proceso Finalizado ---")
    print(f"Archivos copiados exitosamente: {copy_count}")
    print(f"Errores: {error_count}")
    print(f"Nuevo Dataset ubicado en: {TARGET_ROOT}")


if __name__ == '__main__':
    create_subset()